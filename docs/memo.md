# Javascriptのメモ

## 基本的な書き方・ルール

### 記法

* `<script>`要素の中にコードを記述していく。
* 基本的には `</body>`閉じタグの直前に書く。
  * `</body>`タグの直前に記載することで、ページの表示後にスクリプトを読み込むのでページ表示の高速化につながる。
* 文の末尾には `;` （セミコロン）を付ける。
  * 付けなくても動くが、非推奨。
* 大文字と小文字は厳密に区別される。
* コメントは３つの記法が可能。
  * `// comment` ： 単一行コメント。
  * `/* comment */` ： 複数行コメント。
  * `/** comment */` ： ドキュメンテーションコメント。javadoc的なやつ。
  * 基本的には単一行コメントを優先的に使用する。

```html
<body>
    <script type="text/javascript">
        window.alert("Hello World");
    </script>
</body>
```

* Javascriptを外部ファイルにする場合、`<script>`タグの `src` 属性にjavascriptファイルのパスを記載する。
* 外部ファイルの読み込みを行う場合、`<script>`要素内のコードは無視される。

```html
<body>
    <script type="text/javascript" src="./javascript/common.js">
        window.alert("Hello World"); // これは無視される
    </script>
</body>
```

* Javascriptが無効な場合に代替コンテンツを表示させるには、`<noscript>` タグを用いる。

```html
<body>
    <noscript>Javascriptが有効ではありません。</noscript>
</body>
```

* アンカータグにスクリプトを埋め込むこともできる。
* その場合、「`Javascript:~`」の形式で記述する。
* 以下の例だと、aタグの`href`属性にスクリプトを埋め込んでおり、リンクをクリックする度にダイアログが表示される。

```html
<a href="Javascript: window.alert('Hello World');" >ダイアログ表示</a>
```

### 変数・定数

* 変数の宣言は `var 変数名 [=初期値];` で行う。
* 複数の変数を `,` （カンマ）区切りで記述することもできる。

```javascript
var msg; // msgという変数を定義
var x, y; // 複数定義
var hello = 'Hello World'; // 変数の定義と同時に、初期値を設定。
```

* 変数を宣言する命令として `var` 以外に、`let` 命令が使用できる。
* `let`命令は、ES2015から追加された。
* `var` との違いは以下。
  * 変数名の重複を許可しない。
  * ブロックスコープを認識する。

```javascript
// varの場合、変数名の重複は許可されている。
var x = 'hello';
var x = 'world';

// letの場合、変数目の重複は許可されない。
let msg = 'hello';
let msg = 'world'; // 重複ダメ、ぜったい。
```

ブロックスコープについては、あとで説明。<br/>
とりあえず、`var` よりも「変数の有効範囲を細かく管理できる」と理解する。

* 定数を定義する場合には `const` 命令を利用する。
* 構文は変数の定義時と同じように、`const 定数名 = 値;` で行う。

```javascript
const TAX = 1.08;
```

### データ型

Javascriptの主なデータ型は以下。

* 基本型
  * 数値型：number
  * 文字列型：string ・・・ シングル or ダブルクウォートで囲まれた文字
  * 真偽型：boolean ・・・ true / false
  * シンボル型：symbol
  * 特殊型：null / undefined ・・・ 値が空、または未定義
* 参照型
  * 配列：array ・・・ 普通の配列
  * オブジェクト：object ・・・ 連想配列
  * 関数：function

JavascriptはJavaやScalaなどのように静的型付け言語ではないため、データ型を意識しなくてもいい。<br/>
そのため、以下のようなコードもエラーにならない。

```javascript
var value = 'hello';
value = 10;
```

#### リテラル

##### 数値リテラル

| 進法 | 記載方法例 | prefix |
|------|---------|---------|
| 10   | `10`    | -       |
| 16   | `0xFF`  | `0x`    |
| 8    | `0o67`  | `0o`    |
| 2    | `0b101` | `0b`    |

##### 文字リテラル

文字リテラルは

* シングルクォート（`'`）
* ダブルクウォート（`"`）

で囲んだ文字。

```javascript
// 文字リテラル
'Hello World';
"Hello World";
```

エスケープシーケンスは、他の言語と同じ。<br/>
「バックスラッシュ（`\`） + 文字」で表現する。

##### テンプレート文字

javascriptでは「テンプレート文字」が利用できる。

* 文字列へ変数を埋め込むことができる。
* 複数行にまたがる文字列。

以下のような使い方ができる。

```javascript
var name = "田中";
var message = `こんにちは、${name}さん。
今日は暑いですね。`;
console.log(message);
```

テンプレート文字内では改行はそのまま改行として扱われる。<br/>
Scalaでいう、生文字リテラル。

##### 配列リテラル

カンマ（`,`）区切りの値をブラケット（`[...]`）でくくった形式で表現する。

```javascript
[`Javascript`, 'Java', 'Scala', 'C#']
```

配列へのアクセスはインデックス番号をキーとする。<br/>

```javascript
var data = ["a", "b", "c"];
console.log(data[0]); // 実行結果：a
```

入れ子になっている場合も同様。

```javascript
var data = ["a", ["b", "c"], "d"];
console.log(data[1][1]); // 実行結果：c
```

##### オブジェクトリテラル

名前をキーにアクセスできる配列。<br/>
連想配列にあたる。

オブジェクト内の個々の要素は **プロパティ** と呼ぶ。<br/>
プロパティには文字列や数値などに加え、関数を格納することも出来る。<br/>
プロパティとして格納した関数を **メソッド** と呼ぶ。

オブジェクトリテラルの記載は以下の通り。

```javascript
var obj = {x:1, y:2, z:3};
console.log(obj.x);    // 結果：1
console.log(obj['x']); // 結果：1
```

配列はブラケット(`[]`)で囲っているのに対して、オブジェクトは中括弧(`{}`)で囲う。<br/>
また、プロパティへのアクセスはドット演算子かブラケット構文による２つの方法がある。

ドット演算子でアクセスする場合には、プロパティ名は識別子としてみなされるので `obj.123` のような名前は使用できない。<br/>
しかしブラケット構文だとプロパティ名は文字列として指定するので、`obj['123']` はOK。

##### 関数リテラル

後日記載


##### 未定義値

未定義値（`undefined`)は、ある変数の値が定義されていないことを表す値。<br/>
以下のようなケースで返される。
 
* ある変数が宣言済みであるが、値が与えられていない。
* 未定義のプロパティを参照しようとした場合。
* 関数で値が返却されなかった。

```javascript
var x;
var obj = { a: 1234 };
console.log(x);      // 結果：undefined (値が設定されていない）
console.log(obj.b);  // 結果：undefined (プロパティが存在しない)
```

##### null

未定義値の他に、該当する値がないことを表す **null** 値が存在している。<br/>
`undefined` は *定義されていない（参照することを想定していない）* であるのに対し、
`null` は **空である** ことを表す。

意図して空であることを表す場合には`null`を使用し、そうでなければ`undefined`を使用する。

## 演算子

### 分割代入

**分割代入** とは、配列/オブジェクトを個々の変数に分解する構文。

```javascript
let data = [1, 2, 3, 4, 5];
let [x1, x2, x3, x4, x4] = data;

console.log(x1); // 1
console.log(x4); // 4
```

また、`...` 演算子を用いることで、個々に分解されなかった残りの要素をまとめて配列として切り出すことも可能。

```javascript
let data = [1, 2, 3, 4, 5];
let [x1, x2, x3, ...other] = data;

console.log(x1);    // 1
console.log(other); // [4, 5]
```

分割代入は *オブジェクト（連想配列）* にも用いることが可能。<br/>
オブジェクトの場合には、プロパティを変数に分割することになる。

オブジェクトを分割代入する場合、`[]`(ブラケット) ではなく `{}`(中括弧) で囲う。<br/>
プロパティ名を指定するので、順番は問わない。（プロパティ名に紐づく値がバインドされる）<br/>
なお、分割されないプロパティが存在しても問題なく、`プロパティ名 = 値` でデフォルト値を指定することが可能。

```javascript
let human = {name: '田中', age: 18, sex: '男'};
let {name, age, memo = '高校生'} = human;

console.log(name);  // 田中
console.log(age);   // 18
console.log(memo);  // 高校生
```

入れ子になったオブジェクトの場合には、代入先の変数も入れ子にする。

```javascript
let programmer = {name: '田中', age: 20, skill: {sql: true, linux: true, java: false}};
let {name, age, skill: {linux, java}} = programmer;

console.log(linux); // true
console.log(java);  // false
```

入れ子にする場合には `{プロパティ名: { プロパティ名, ... }}` という形式にする。


### 比較演算子

| 演算子  | `true` を返す条件 | 使用例 |
|:------:|:----|:------|
| `==`   | 左辺と右辺の値が等しい場合                            | `1 == 1` |
| `!=`   | 左辺と右辺の値が等しくない場合                        | `1 != 2` |
| `<`    | 左辺が右辺より小さい場合                              | `1 < 2` |
| `<=`   | 左辺が右辺以下の場合                                  | `1 <= 1` |
| `>`    | 左辺が右辺よりも大きい場合                             | `2 > 1` |
| `>=`   | 左辺が右辺以上の場合                                  | `2 >= 2` |
| `===`  | 左辺と右辺の値が等しく、データ型も一致している場合        | `1 === 1` |
| `!==`  | 左辺と右辺の値が等しくない、またはデータ型が一致しない場合 | `1 !== 2` |
| `?:`   | 三項演算子                                          | `(1 == 1) ? 0 : 1` |


#### 等価演算子（`==`）

左辺と右辺が等しい場合には `true` を返却する。<br/>
比較するデータ型によって、その比較基準が異なる。

* 左辺と右辺が同一のデータ型
  * 文字列 / 数値 / 論理値 : 双方の値が等しいか
  * 配列 / オブジェクト    : 参照先が等しいか
  * null / undefined     : 双方とも null / undefined であるか。(null と undefined の比較は true)
* 左辺と右辺が異なるデータ型
  * 文字列 / 数値 / 論理値  : 文字列、または数値に変換したうえで判定
  * オブジェクト            : 基本型に変換したうえで判定

### 制御構文

#### if

他の言語と同じ。

```javascript
if( 条件1 ) {
    // 条件1が true の場合の処理
} else if ( 条件2 ) {
    // 条件2が true の場合の処理
} else {
    // それ以外の場合の処理
}
```

#### switch

これも他の言語と同じ。<br/>
各ブロックで `break` 命令を記載しなければ、そのまま下のブロックのまで行う。<br/>
なお、switch式のcase値は `===`（同値演算子）で比較される。

```javascript
switch ( 式 ) {
    case 値1 :
        // 式の戻り値が 値1 の場合
        break;
    case 値2 :
        // 式の戻り値が 値2 の場合
        break;
    default :
        // 式の戻り値が上記以外の場合
}
```

#### while / do...while

他の言語と同じ。

```javascript
while( 条件式 ) {
    // 条件式が true を返す場合の処理
}
```

```javascript
do {
    // 条件式が true を返す場合の処理
}while( 条件式 );
```

#### for

他の言語と同じ。

```javascript
for( 初期化式; 継続条件式; 増減式) {
    // ループ内の処理
}
```

#### for-in

連想配列をループする場合に使用する。

```javascript
for( 仮変数 in 連想配列){
    // ループ処理
}

// 連想配列 data をfor-inで処理
var data = {one: 1, two: 2, three: 3};
for(var key : data){
    console.log(data[key]);
}
```

仮変数には連想配列のキーが代入される。<br/>
配列にも for-in は使用可能だが、使用しないほうがいい。(for または後述する、for...ofを使用する)

#### for...of

配列などを順番に処理していくループ。<br/>
ES2015で追加された機能。

Javaでいうイテレータチックな値を逐次処理できる。

```javascript
for( 仮変数 of 列挙可能なオブジェクト){
    // ループ内の処理
}
```

基本的には for...in と一緒。<br/>
for...inでは連想配列のキーを渡していたのに対して、for..ofでは値を渡す。


#### continue / break

ループや処理を途中で抜ける、スキップする。<br/>
ネストされたループ内で continue / break を使用した場合には、最も内側のループを脱出/スキップする。

```javascript
for(var i = 0; i < 10; i++){
    for(var j = 0; j < 5; j++){
        if(j % 2 == 0) continue;  // 一番内側のループをスキップ
        console.log(i * j);
    }
    
    if(i === 7) break;
}
```

ネストされたループそのものから脱出したい場合には、ラベルを利用する。<br/>
このあたりは、Javaと同じ仕組み。

```javascript
hoge:
for(var i = 0; i < 10; i++){
    for(var j = 0; j < 5; j++){
        if(i === 7) break hoge;   // ループそのものを脱出
        if(j % 2 == 0) continue;  // 一番内側のループをスキップ
        console.log(i * j);
    }
}
```

#### try...catch...finally

他の言語と基本的に同じ。<br/>
異なる点としては、catch句のは例外を受け取る変数を定義するだけ。（例外の種類を明記しない）

```javascript
try {
    // 例外が発生するかもしれない処理
}catch ( 例外を受け取る変数 ){
    // 例外発生時の処理
}finally {
    // 例外の有無に関係なく、最後に実行される処理
}
```

自分で明示的に例外を発生させるには、`throw`句 を用いる。

```javascript
throw new Error('エラーメッセージ');
```

発生させることのできるエラーには以下のようなものがある。

* EvalError : 不正なeval関数
* RangeError : 指定された値が許容範囲を超えている
* ReferenceError : 宣言されていない変数にアクセスした
* SyntaxError : 文法エラー
* TypeError : 指定された値が期待するデータ型ではない
* URIError : 不正なURI

#### Strictモード

Javascriptの落とし穴を検知し、エラーとして通知してくれる仕組みのこと。<br/>
Strictモードを有効にするには、スクリプトの先頭、もしくは関数の先頭に 「`use strict;`」 と宣言するだけ。

```javascript
'use strict'; // スクリプトの先頭

function func() {
    `use strict`; // 関数の先頭
}
```

Strictモードを有効にすると以下のような制限がかかる。（代表する制限を列挙）

* 変数
  * var命令の省略を禁止。
  * 将来的に追加予定のキーワードを予約後に追加。
  * 引数 / プロパティ名の重複を禁止。
  * null / undefined への代入を禁止。
* 命令
  * with命令の利用を禁止。
  * arguments.callee プロパティへのアクセスを禁止。
  * eval命令で宣言された変数を、周辺のスコープに拡散しない。
* その他
  * 関数配下の `this` は、グローバルオブジェクトを参照しない。
  * 8進数表記を禁止する。


